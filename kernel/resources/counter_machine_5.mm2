; Monotonic rewriting system version of https://en.wikipedia.org/wiki/Counter_machine#Program
; The following program is encoded in S-expressions or the metagraph
; Function: it copies the contents of register 2 to register 3
; 0   1   2   3   4   5   6   7   8   9
; JZ  DEC INC INC JZ  JZ  DEC INC JZ  H  ; instruction
; 2   2   3   1   0   1   1   2   0      ; register it checks
; 6               1   10          6      ; jump to instruction number
(program Z (JZ 2 (S (S (S (S (S Z))))) ))
(program (S Z) (DEC 2))
(program (S (S Z)) (INC 3))
(program (S (S (S Z))) (INC 1))
(program (S (S (S (S Z)))) (JZ 0 Z))
(program (S (S (S (S (S Z))))) (JZ 1 (S (S (S (S (S (S (S (S (S Z)))))))))))
(program (S (S (S (S (S (S Z)))))) (DEC 1))
(program (S (S (S (S (S (S (S Z))))))) (INC 2))
(program (S (S (S (S (S (S (S (S Z)))))))) (JZ 0 (S (S (S (S (S Z)))))))
(program (S (S (S (S (S (S (S (S (S Z))))))))) H)
; Initial state of the registers
; 0 1 2 3 4  ; register
; 0 0 5 0 0  ; contents
(state Z (REG 0 Z))
(state Z (REG 1 Z))
(state Z (REG 2 (S (S (S (S (S Z)))))))
(state Z (REG 3 Z))
(state Z (REG 4 Z))
(state Z (IC Z))
; (if <peano_nonzero> <then> <else> <result>)
(if (S $n) $x $y $x)
(if Z $x $y $y)
; Get all other registers (can be done via grounding, written out here)
(0 != 1) (0 != 2) (0 != 3) (0 != 4)
(1 != 0) (1 != 2) (1 != 3) (1 != 4)
(2 != 1) (2 != 0) (2 != 3) (2 != 4)
(3 != 1) (3 != 2) (3 != 0) (3 != 4)
(4 != 1) (4 != 2) (4 != 0) (4 != 3)

; These are the three rules "(state k <previous_state>) => (state <k+1> <next_state>)" that evolve the system
; Update instruction counter to $j if $r is zero (keep the rest the same)
((step JZ $ts)
; for the current IC, maybe get the JZ instruction, get the register it checks, calculate next IC, and get all other state
  (, (state $ts (IC $i)) (program $i (JZ $r $j)) (state $ts (REG $r $v)) (if $v (S $i) $j $ni) (state $ts (REG $k $kv)))
; set the next calculate IC, and and keep all registers the same
  (, (state (S $ts) (IC $ni)) (state (S $ts) (REG $k $kv))))

; Increment register $r (keep the rest the same)
((step INC $ts)
; for the current UC, maybe get the INC instruction, get the register, and all other, registers
  (, (state $ts (IC $i)) (program $i (INC $r)) (state $ts (REG $r $v)) ($r != $o) (state $ts (REG $o $ov)))
; set the next IC (just incremented), the calculated new register value, and keep all other registers
  (, (state (S $ts) (IC (S $i))) (state (S $ts) (REG $r (S $v))) (state (S $ts) (REG $o $ov))))

; Decrement register $r (keep the rest the same), analogous to INC
((step DEC $ts)
  (, (state $ts (IC $i)) (program $i (DEC $r)) (state $ts (REG $r (S $v))) ($r != $o) (state $ts (REG $o $ov)))
  (, (state (S $ts) (IC (S $i))) (state (S $ts) (REG $r $v)) (state (S $ts) (REG $o $ov))))  

; Halt (do not keep the rest)
; <nothing to carry over to the next state>

; Run the counter machine, increment the clock every cycle, keeping all previous states
; Only scheduling the next batch of steps for execution when there's a next timestep state (not the case with halt)
(exec (clocked Z)
        (, (exec (clocked $ts) $p1 $t1) 
           (state $ts (IC $_))
           ((step $k $ts) $p0 $t0))
        (, (exec ($k $ts) $p0 $t0)
           (exec (clocked (S $ts)) $p1 $t1)))
